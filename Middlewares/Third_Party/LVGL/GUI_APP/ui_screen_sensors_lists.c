/**
 * @file      ui_screen_sensors_lists.c
 * @brief     传感器列表页面模块 (动态刷新版)
 * @details   动态创建传感器列表，并定时刷新每个传感器的状态和实时数据。
 * @author    MmsY (Generated by Gemini)
 * @date      2025
 */

#include "ui_screen_sensors_lists.h"
#include "ui_manager.h"
#include "sensor_task.h"
#include "ui_comp_navbar.h"
#include "ui_comp_header.h"  // [NEW] 引入顶部栏组件

LV_FONT_DECLARE(my_font_yahei_24);

/**
 * @brief 传感器列表项UI控件集合
 */
typedef struct {
    lv_obj_t* container;    // 列表项的根容器
    lv_obj_t* status_led;   // 状态指示灯
    lv_obj_t* value_label;  // 实时数据显示标签
} sensors_list_item_ui_t;  // [CHANGED] 重命名结构体

/**
 * @brief 传感器列表页面UI控件集合
 */
typedef struct {
    ui_header_t* header;                                      // [NEW] 顶部栏组件句柄
    sensors_list_item_ui_t items[SENSOR_TYPE_MAX];           // [CHANGED] 使用新结构体名
    lv_timer_t* update_timer;                                 // 数据更新定时器
} sensors_lists_ui_t;  // [NEW] 新增整体UI结构体

/* 全局变量 */
static sensors_lists_ui_t g_sensors_lists_ui;  // [CHANGED] 重命名并使用新结构体

/* -----------------------------------------------------------
 * 前向声明
 * ----------------------------------------------------------- */
static void back_btn_event_cb(lv_event_t* e);
static void sensor_item_click_event_cb(lv_event_t * e);
static void sensors_lists_update_timer_cb(lv_timer_t* timer);  // [CHANGED] 重命名函数

/* -----------------------------------------------------------
 * 回调函数实现
 * ----------------------------------------------------------- */

/**
 * @brief 返回按钮事件回调
 */
static void back_btn_event_cb(lv_event_t* e)
{
    (void)e;
    ui_load_previous_screen();
}

/**
 * @brief 列表中某个传感器按钮被点击时的事件回调
 */
static void sensor_item_click_event_cb(lv_event_t * e)
{
    SensorType_t sensor_type = (SensorType_t)(intptr_t)lv_event_get_user_data(e);
    ui_set_active_sensor(sensor_type);
    ui_load_screen(UI_SCREEN_SENSORS_DETAILS);  // [CHANGED] 使用新的枚举名
}

/**
 * @brief 定时器回调，用于刷新列表上所有传感器的状态和数据
 */
static void sensors_lists_update_timer_cb(lv_timer_t* timer)  // [CHANGED] 重命名函数
{
    (void)timer;
    SensorData_t data;
    SensorStatus_t status;

    /* 循环遍历所有传感器 */
    for (int i = SENSOR_TYPE_NONE + 1; i < SENSOR_TYPE_MAX; i++) {
        SensorType_t current_type = (SensorType_t)i;
        sensors_list_item_ui_t* item_ui = &g_sensors_lists_ui.items[current_type];  // [CHANGED] 使用新变量名

        /* 1. 更新状态指示灯 */
        if (SensorTask_GetSensorStatus(current_type, &status)) {
            switch (status) {
                case SENSOR_STATUS_ONLINE:
                    lv_led_set_color(item_ui->status_led, lv_palette_main(LV_PALETTE_GREEN));
                    break;
                case SENSOR_STATUS_ERROR:
                    lv_led_set_color(item_ui->status_led, lv_palette_main(LV_PALETTE_RED));
                    break;
                case SENSOR_STATUS_INITIALIZING:
                    lv_led_set_color(item_ui->status_led, lv_palette_main(LV_PALETTE_ORANGE));
                    break;
                case SENSOR_STATUS_OFFLINE:
                default:
                    lv_led_set_color(item_ui->status_led, lv_palette_main(LV_PALETTE_GREY));
                    break;
            }
        }

        /* 2. 更新实时数据 */
        if (status == SENSOR_STATUS_ONLINE && SensorTask_GetSensorData(current_type, &data) && data.is_valid) {
            if (current_type == SENSOR_TYPE_SHT30) {
                lv_label_set_text_fmt(item_ui->value_label, "%.1f °C / %.1f %%", 
                                     data.values.sht30.temp, data.values.sht30.humi);
            } else if (current_type == SENSOR_TYPE_GY30) {
                lv_label_set_text_fmt(item_ui->value_label, "%.0f Lux", data.values.gy30.lux);
            } else if (current_type == SENSOR_TYPE_SMOKE) {
                lv_label_set_text_fmt(item_ui->value_label, "%d PPM", data.values.smoke.ppm);
            }
        } else {
            /* 如果传感器不在线或数据无效，显示占位符 */
            lv_label_set_text(item_ui->value_label, "--");
        }
    }
}

/* -----------------------------------------------------------
 * 界面初始化与反初始化
 * ----------------------------------------------------------- */

/**
 * @brief 初始化传感器列表屏幕
 */
void ui_screen_sensors_lists_init(lv_obj_t* parent)  // [CHANGED] 重命名函数
{
    memset(&g_sensors_lists_ui, 0, sizeof(sensors_lists_ui_t));
    lv_obj_set_flex_flow(parent, LV_FLEX_FLOW_COLUMN);

    /* === 1. 使用 ui_comp_header 创建顶部栏 === */
    ui_header_config_t header_config = {
        .title = "传感器列表",
        .show_back_btn = true,
        .show_custom_btn = false,
        .custom_btn_text = NULL,
        .back_btn_cb = back_btn_event_cb,
        .custom_btn_cb = NULL,
        .user_data = NULL,
        .show_time = true
    };
    
    g_sensors_lists_ui.header = ui_comp_header_create(parent, &header_config);

    /* === 2. 创建一个可滚动的列表容器 === */
    lv_obj_t * list_container = lv_obj_create(parent);
    lv_obj_remove_style_all(list_container);
    lv_obj_set_width(list_container, LV_PCT(100));
    lv_obj_set_flex_grow(list_container, 1);
    lv_obj_set_flex_flow(list_container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_style_pad_all(list_container, 10, 0);
    lv_obj_set_style_pad_gap(list_container, 10, 0);

    /* === 3. 动态创建传感器列表项 === */
    for (int i = SENSOR_TYPE_NONE + 1; i < SENSOR_TYPE_MAX; i++) {
        SensorType_t current_type = (SensorType_t)i;
        sensors_list_item_ui_t* item_ui = &g_sensors_lists_ui.items[current_type];  // [CHANGED] 使用新变量名

        /* 创建根容器 (一个可点击的面板) */
        item_ui->container = lv_obj_create(list_container);
        lv_obj_set_size(item_ui->container, LV_PCT(100), 70);
        lv_obj_add_flag(item_ui->container, LV_OBJ_FLAG_CLICKABLE);
        lv_obj_add_event_cb(item_ui->container, sensor_item_click_event_cb, LV_EVENT_CLICKED, 
                           (void*)(intptr_t)current_type);

        /* 左侧：状态指示灯 */
        item_ui->status_led = lv_led_create(item_ui->container);
        lv_obj_align(item_ui->status_led, LV_ALIGN_LEFT_MID, 15, 0);
        lv_led_on(item_ui->status_led);

        /* 中间：传感器名称 */
        lv_obj_t* name_label = lv_label_create(item_ui->container);
        lv_label_set_text(name_label, SensorType_ToString(current_type));
        lv_obj_set_style_text_font(name_label, &my_font_yahei_24, 0);
        lv_obj_align_to(name_label, item_ui->status_led, LV_ALIGN_OUT_RIGHT_MID, 15, 0);

        /* 右侧：详情箭头 */
        lv_obj_t* arrow_label = lv_label_create(item_ui->container);
        lv_label_set_text(arrow_label, LV_SYMBOL_RIGHT);
        lv_obj_align(arrow_label, LV_ALIGN_RIGHT_MID, -15, 0);

        /* 右中：实时数值 */
        item_ui->value_label = lv_label_create(item_ui->container);
        lv_label_set_text(item_ui->value_label, "--");
        lv_obj_set_style_text_align(item_ui->value_label, LV_TEXT_ALIGN_RIGHT, 0);
        lv_obj_align_to(item_ui->value_label, arrow_label, LV_ALIGN_OUT_LEFT_MID, -15, 0);
    }

    /* === 4. 创建底部导航栏 === */
    ui_comp_navbar_create(parent, UI_SCREEN_SENSORS_LISTS);  // [CHANGED] 使用新的枚举名
    
    /* === 5. 启动定时器以刷新列表数据 === */
    g_sensors_lists_ui.update_timer = lv_timer_create(sensors_lists_update_timer_cb, 1000, NULL);
    sensors_lists_update_timer_cb(g_sensors_lists_ui.update_timer); // 立即执行一次
}

/**
 * @brief 销毁列表屏幕时调用的清理函数
 */
void ui_screen_sensors_lists_deinit(void)  // [CHANGED] 重命名函数
{
    /* 销毁顶部栏 */
    if (g_sensors_lists_ui.header) {
        ui_comp_header_destroy(g_sensors_lists_ui.header);
        g_sensors_lists_ui.header = NULL;
    }
    
    /* 删除定时器 */
    if (g_sensors_lists_ui.update_timer) {
        lv_timer_del(g_sensors_lists_ui.update_timer);
        g_sensors_lists_ui.update_timer = NULL;
    }
}
